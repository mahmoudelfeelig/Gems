name: Perf

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]
  pull_request:
    types: [ opened, synchronize, reopened, labeled ]

permissions:
  contents: read

jobs:
  perf:
    # Run on demand, on main, or on PRs explicitly labeled "run-perf".
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'run-perf'))
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Build
        shell: bash
        run: |
          set -euo pipefail
          if [[ -f gradle/wrapper/gradle-wrapper.jar ]]; then
            chmod +x ./gradlew
            ./gradlew --no-daemon build
            exit 0
          fi

          echo "gradle-wrapper.jar is missing; bootstrapping Gradle from distributionUrl for CI..."
          url="$(grep -E '^distributionUrl=' gradle/wrapper/gradle-wrapper.properties | cut -d= -f2-)"
          curl -fsSL "$url" -o /tmp/gradle.zip
          unzip -q /tmp/gradle.zip -d /tmp/gradle
          gradle_bin="$(find /tmp/gradle -maxdepth 3 -type f -path '*/bin/gradle' | head -n1)"
          chmod +x "$gradle_bin"
          "$gradle_bin" --no-daemon build

      - name: Perf smoke (20 Carpet bots + force stress)
        shell: bash
        run: |
          set -euo pipefail

          # Resolve a Gradle binary (wrapper if present, otherwise bootstrap).
          GRADLE="./gradlew"
          if [[ ! -f gradle/wrapper/gradle-wrapper.jar ]]; then
            url="$(grep -E '^distributionUrl=' gradle/wrapper/gradle-wrapper.properties | cut -d= -f2-)"
            curl -fsSL "$url" -o /tmp/gradle.zip
            unzip -q /tmp/gradle.zip -d /tmp/gradle
            GRADLE="$(find /tmp/gradle -maxdepth 3 -type f -path '*/bin/gradle' | head -n1)"
            chmod +x "$GRADLE"
          else
            chmod +x ./gradlew
          fi

          mkdir -p run/mods
          cat > run/eula.txt <<'EOF'
          eula=true
          EOF

          cat > run/server.properties <<'EOF'
          enable-rcon=true
          rcon.password=perf
          rcon.port=25575
          online-mode=false
          allow-flight=true
          view-distance=2
          simulation-distance=2
          spawn-protection=0
          max-players=50
          motd=gems-perf
          level-name=perfworld
          level-type=minecraft:flat
          sync-chunk-writes=false
          EOF

          CARPET_URL="$(python3 - <<'PY'
          import json
          import urllib.parse
          import urllib.request
          
          base = 'https://api.modrinth.com/v2/project/carpet/version'
          params = {
              'game_versions': json.dumps(['1.21.1']),
              'loaders': json.dumps(['fabric']),
          }
          url = base + '?' + urllib.parse.urlencode(params)
          req = urllib.request.Request(url, headers={'User-Agent': 'gems-perf-ci'})
          with urllib.request.urlopen(req) as r:
              data = json.loads(r.read().decode('utf-8'))
          if not data:
              raise SystemExit('No Carpet versions found for 1.21.1 + fabric')
          print(data[0]['files'][0]['url'])
          PY
          )"
          echo "Downloading Carpet: $CARPET_URL"
          curl -sSL "$CARPET_URL" -o run/mods/carpet.jar

          "$GRADLE" --no-daemon runServer --args "nogui" > server.log 2>&1 &
          SERVER_PID=$!

          cleanup() {
            if kill -0 "$SERVER_PID" 2>/dev/null; then
              echo "Stopping server..."
              python3 .github/rcon.py 127.0.0.1 25575 perf "stop" || true
              sleep 2 || true
              kill "$SERVER_PID" || true
            fi
          }
          trap cleanup EXIT

          cat > .github/rcon.py <<'PY'
          import socket, struct, sys

          def _pkt(req_id: int, req_type: int, payload: str) -> bytes:
              data = payload.encode('utf-8') + b'\x00\x00'
              body = struct.pack('<ii', req_id, req_type) + data
              return struct.pack('<i', len(body)) + body

          def _recv(sock: socket.socket):
              raw_len = sock.recv(4)
              if len(raw_len) != 4:
                  raise RuntimeError('short read')
              (length,) = struct.unpack('<i', raw_len)
              raw = b''
              while len(raw) < length:
                  chunk = sock.recv(length - len(raw))
                  if not chunk:
                      break
                  raw += chunk
              if len(raw) != length:
                  raise RuntimeError('short packet')
              req_id, req_type = struct.unpack('<ii', raw[:8])
              payload = raw[8:-2].decode('utf-8', errors='replace')
              return req_id, req_type, payload

          def rcon(host: str, port: int, password: str, command: str) -> str:
              with socket.create_connection((host, port), timeout=2.0) as sock:
                  sock.sendall(_pkt(1, 3, password))  # login
                  rid, _, _ = _recv(sock)
                  if rid == -1:
                      raise SystemExit('RCON auth failed')
                  sock.sendall(_pkt(2, 2, command))  # command
                  out = []
                  # responses may be split; read until timeout
                  sock.settimeout(0.4)
                  while True:
                      try:
                          _, _, payload = _recv(sock)
                          out.append(payload)
                      except socket.timeout:
                          break
                  return ''.join(out).strip()

          if __name__ == '__main__':
              host = sys.argv[1]
              port = int(sys.argv[2])
              password = sys.argv[3]
              command = ' '.join(sys.argv[4:])
              print(rcon(host, port, password, command))
          PY

          echo "Waiting for RCON..."
          for _ in $(seq 1 180); do
            if python3 .github/rcon.py 127.0.0.1 25575 perf "list" >/dev/null 2>&1; then
              break
            fi
            sleep 1
          done

          rcon() { python3 .github/rcon.py 127.0.0.1 25575 perf "$@"; }

          rcon "gamerule doMobSpawning false" || true
          rcon "gamerule doWeatherCycle false" || true
          rcon "gamerule randomTickSpeed 0" || true
          rcon "gems admin perf reset"

          echo "Spawning Carpet bots..."
          for i in $(seq 1 20); do
            rcon "player bot$i spawn"
          done

          rcon "gems admin setEnergy @a 10"
          rcon "gems admin resync @a"

          # Warm-up buffer
          sleep 5
          rcon "gems admin perf reset"

          # Force-mode stress is intentionally harsh; keep period=20t to reduce entity spam.
          rcon "gems admin stress start @a 60 20 force true true"
          sleep 65
          rcon "gems admin stress stop @a" || true

          OUT="$(rcon "gems admin perf snapshot 1200" | tr -d '\r')"
          echo "$OUT"

          P95="$(echo "$OUT" | sed -n 's/.*p95_mspt=\\([0-9.]*\\).*/\\1/p')"
          AVG="$(echo "$OUT" | sed -n 's/.*avg_mspt=\\([0-9.]*\\).*/\\1/p')"
          test -n "$P95"
          test -n "$AVG"
          echo "Parsed avg_mspt=$AVG p95_mspt=$P95"

          # Guardrails for regression detection (kept intentionally lenient for shared CI runners).
          awk -v avg="$AVG" -v p95="$P95" 'BEGIN{ exit !((avg+0) <= 40.0 && (p95+0) <= 120.0) }'

      - name: Upload server log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: perf-server-log
          path: server.log
